import{a as w}from"./chunk-HZFO2ZNC.mjs";import{a as A,c as _,d as D,e as S,f as x,i as P,j as M,k as R,l as N,m as v}from"./chunk-QLDCU3AK.mjs";import{a as p}from"./chunk-G6NXRO24.mjs";import{a as T}from"./chunk-CSO5SXZE.mjs";import{a as q}from"./chunk-4MIIWOU6.mjs";import{a as f}from"./chunk-2VGOQ75U.mjs";import{a as O}from"./chunk-YSXGDEY5.mjs";import{Tool as l}from"@goat-sdk/core";import{EVMWalletClient as c}from"@goat-sdk/wallet-evm";import{parseUnits as I}from"viem";import{encodeAbiParameters as F}from"viem";function m(g,n,t,e){var a=arguments.length,i=a<3?n:e===null?e=Object.getOwnPropertyDescriptor(n,t):e,s;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(g,n,t,e);else for(var r=g.length-1;r>=0;r--)(s=g[r])&&(i=(a<3?s(i):a>3?s(n,t,i):s(n,t))||i);return a>3&&i&&Object.defineProperty(n,t,i),i}O(m,"_ts_decorate");function o(g,n){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(g,n)}O(o,"_ts_metadata");var y="0xAc48FcF1049668B285f3dC72483DF5Ae2162f7e8",h="0x2e8614625226D26180aDf6530C3b1677d3D7cf10",G="0xB5F00c2C5f8821155D8ed27E31932CFD9DB3C5D5",d=class{static{O(this,"KimService")}async getSwapRouterAddress(n){return y}async swapExactInputSingleHop(n,t){try{let e=await n.sendTransaction({to:t.tokenInAddress,abi:p,functionName:"approve",args:[y,t.amountIn]}),a=Math.floor(Date.now()/1e3)+t.deadline;return(await n.sendTransaction({to:y,abi:w,functionName:"exactInputSingle",args:[{tokenIn:t.tokenInAddress,tokenOut:t.tokenOutAddress,recipient:n.getAddress(),deadline:a,amountIn:t.amountIn,amountOutMinimum:t.amountOutMinimum,limitSqrtPrice:t.limitSqrtPrice}]})).hash}catch(e){throw Error(`Failed to swap exact input single hop: ${e}`)}}async swapExactOutputSingleHop(n,t){try{let e=t.tokenInAddress,a=t.tokenOutAddress,i=t.amountOut,s=t.amountInMaximum,r=t.limitSqrtPrice,u=Math.floor(Date.now()/1e3)+t.deadline,b=await n.sendTransaction({to:t.tokenInAddress,abi:p,functionName:"approve",args:[y,s]});return(await n.sendTransaction({to:y,abi:w,functionName:"exactOutputSingle",args:[{tokenIn:e,tokenOut:a,recipient:n.getAddress(),deadline:u,amountOut:i,amountInMaximum:s,limitSqrtPrice:r}]})).hash}catch(e){throw Error(`Failed to swap exact output single hop: ${e}`)}}async swapExactInputMultiHop(n,t){try{let e=await n.resolveAddress(t.recipient),a=Number(await n.read({address:t.path.tokenIn,abi:p,functionName:"decimals"})),i=Number(await n.read({address:t.path.tokenOut,abi:p,functionName:"decimals"})),s=F([{type:"address[]"},{type:"uint24[]"}],[[t.path.tokenIn,...t.path.intermediateTokens.map(u=>u),t.path.tokenOut],t.path.fees]);return(await n.sendTransaction({to:y,abi:w,functionName:"exactInput",args:[s,e,t.deadline,I(t.amountIn,a),I(t.amountOutMinimum,i)]})).hash}catch(e){throw new Error(`Failed to swap: ${e}`)}}async swapExactOutputMultiHop(n,t){try{let e=await n.resolveAddress(t.recipient),a=Number(await n.read({address:t.path.tokenIn,abi:p,functionName:"decimals"})),i=Number(await n.read({address:t.path.tokenOut,abi:p,functionName:"decimals"})),s=F([{type:"address[]"},{type:"uint24[]"}],[[t.path.tokenIn,...t.path.intermediateTokens.map(u=>u),t.path.tokenOut],t.path.fees]);return(await n.sendTransaction({to:y,abi:w,functionName:"exactOutput",args:[s,e,t.deadline,I(t.amountOut,i),I(t.amountInMaximum,a)]})).hash}catch(e){throw new Error(`Failed to swap: ${e}`)}}async mintPosition(n,t){try{let a=t.token0Address.toLowerCase()<t.token1Address.toLowerCase(),[i,s]=a?[t.token0Address,t.token1Address]:[t.token1Address,t.token0Address],[r,u]=a?[t.amount0Desired,t.amount1Desired]:[t.amount1Desired,t.amount0Desired],k=(await n.read({address:G,abi:T,functionName:"poolByPair",args:[i,s]})).value,L=(await n.read({address:k,abi:q,functionName:"globalState"})).value,H=Number.parseInt(L[1].toString()),E=Math.floor(H/60)*60,B=E-60*10,$=E+60*10,W=await n.sendTransaction({to:i,abi:p,functionName:"approve",args:[h,r]}),Y=await n.sendTransaction({to:s,abi:p,functionName:"approve",args:[h,u]}),U=Math.floor(Date.now()/1e3)+t.deadline;return(await n.sendTransaction({to:h,abi:f,functionName:"mint",args:[{token0:i,token1:s,tickLower:B,tickUpper:$,amount0Desired:r,amount1Desired:u,amount0Min:0,amount1Min:0,recipient:n.getAddress(),deadline:U}]})).hash}catch(e){throw new Error(`Failed to mint position: ${e}`)}}async increaseLiquidity(n,t){try{let e=t.token0Address.toLowerCase()<t.token1Address.toLowerCase(),[a,i]=e?[t.token0Address,t.token1Address]:[t.token1Address,t.token0Address],[s,r]=e?[t.amount0Desired,t.amount1Desired]:[t.amount1Desired,t.amount0Desired],u=await n.sendTransaction({to:a,abi:p,functionName:"approve",args:[h,s]}),b=await n.sendTransaction({to:i,abi:p,functionName:"approve",args:[h,r]}),k=Math.floor(Date.now()/1e3)+60;return(await n.sendTransaction({to:h,abi:f,functionName:"increaseLiquidity",args:[{tokenId:t.tokenId,amount0Desired:s,amount1Desired:r,amount0Min:0n,amount1Min:0n,deadline:k}]})).hash}catch(e){throw new Error(`Failed to increase liquidity: ${e}`)}}async decreaseLiquidity(n,t){try{let s=(await n.read({address:h,abi:f,functionName:"positions",args:[t.tokenId]})).value[6]*BigInt(t.percentage)/BigInt(100),r=0n,u=0n,b=Math.floor(Date.now()/1e3)+60;return(await n.sendTransaction({to:h,abi:f,functionName:"decreaseLiquidity",args:[{tokenId:t.tokenId,liquidity:s,amount0Min:r,amount1Min:u,deadline:b}]})).hash}catch(e){throw new Error(`Failed to decrease liquidity: ${e}`)}}async collect(n,t){try{let e=n.getAddress(),a=BigInt(2**128)-BigInt(1);return(await n.sendTransaction({to:h,abi:f,functionName:"collect",args:[{tokenId:t.tokenId,recipient:e,amount0Max:a,amount1Max:a}]})).hash}catch(e){throw new Error(`Failed to collect: ${e}`)}}async burn(n,t){try{return(await n.sendTransaction({to:h,abi:f,functionName:"burn",args:[t.tokenId]})).hash}catch(e){throw new Error(`Failed to burn position: ${e}`)}}};m([l({name:"kim_get_swap_router_address",description:"Get the address of the swap router"}),o("design:type",Function),o("design:paramtypes",[typeof A>"u"?Object:A]),o("design:returntype",Promise)],d.prototype,"getSwapRouterAddress",null);m([l({description:"Swap an exact amount of input tokens for an output token in a single hop. Have the token amounts in their base units. Don't need to approve the swap router for the output token. User will have sufficient balance of the input token. The swap router address is already provided in the function. Returns a transaction hash on success. Once you get a transaction hash, the swap is complete - do not call this function again."}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof S>"u"?Object:S]),o("design:returntype",Promise)],d.prototype,"swapExactInputSingleHop",null);m([l({name:"kim_swap_exact_output_single_hop",description:"Swap an exact amount of output tokens for a single hop. Have the token amounts in their base units. Don't need to approve the swap router for the output token. User will have sufficient balance of the input token. The swap router address is already provided in the function. Returns a transaction hash on success. Once you get a transaction hash, the swap is complete - do not call this function again."}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof x>"u"?Object:x]),o("design:returntype",Promise)],d.prototype,"swapExactOutputSingleHop",null);m([l({name:"kim_swap_exact_input_multi_hop",description:"Swap an exact amount of input tokens in multiple hops"}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof _>"u"?Object:_]),o("design:returntype",Promise)],d.prototype,"swapExactInputMultiHop",null);m([l({name:"kim_swap_exact_output_multi_hop",description:"Swap tokens to receive an exact amount of output tokens in multiple hops"}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof D>"u"?Object:D]),o("design:returntype",Promise)],d.prototype,"swapExactOutputMultiHop",null);m([l({name:"kim_mint_position",description:"Mint a new liquidity position in a pool. Returns a transaction hash on success. Once you get a transaction hash, the mint is complete - do not call this function again."}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof P>"u"?Object:P]),o("design:returntype",Promise)],d.prototype,"mintPosition",null);m([l({name:"kim_increase_liquidity",description:"Increase liquidity in an existing position. Returns a transaction hash on success. Once you get a transaction hash, the increase is complete - do not call this function again."}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof M>"u"?Object:M]),o("design:returntype",Promise)],d.prototype,"increaseLiquidity",null);m([l({name:"kim_decrease_liquidity",description:"Decrease liquidity in an existing position by specifying a percentage (0-100). Returns a transaction hash on success. Once you get a transaction hash, the decrease is complete - do not call this function again."}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof R>"u"?Object:R]),o("design:returntype",Promise)],d.prototype,"decreaseLiquidity",null);m([l({name:"kim_collect",description:"Collect all available tokens from a liquidity position. Can be rewards or tokens removed from a liquidity position. So, should be called after decreasing liquidity as well as on its own."}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof N>"u"?Object:N]),o("design:returntype",Promise)],d.prototype,"collect",null);m([l({name:"kim_burn",description:"Burn a liquidity position NFT after all tokens have been collected."}),o("design:type",Function),o("design:paramtypes",[typeof c>"u"?Object:c,typeof v>"u"?Object:v]),o("design:returntype",Promise)],d.prototype,"burn",null);export{d as a};
